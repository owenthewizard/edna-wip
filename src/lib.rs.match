#![no_std]
#![cfg_attr(feature = "forbid-unsafe", forbid(unsafe_code))]
#![warn(
    clippy::undocumented_unsafe_blocks,
    clippy::pedantic,
    clippy::nursery,
    //clippy::arbitrary_source_item_ordering,
    clippy::std_instead_of_core
)]
#![allow(clippy::wildcard_imports)]
// TODO development
#![allow(unused_imports, dead_code)]

extern crate alloc;
use alloc::{borrow::Cow, string::String, vec::Vec};

#[cfg(not(feature = "forbid-unsafe"))]
use core::hint::unreachable_unchecked;

use unicode_normalization::{is_nfc, UnicodeNormalization};

use thiserror::Error;

#[global_allocator]
static ALLOC: rpmalloc::RpMalloc = rpmalloc::RpMalloc;

mod status;
pub(crate) use status::*;

mod idna_map {
    include!(concat!(env!("OUT_DIR"), "/idna_map.rs"));
}
use idna_map::*;

pub mod punycode;

pub(crate) type Utf32 = Vec<char>;

#[allow(clippy::struct_excessive_bools)]
struct ToAsciiConfig {
    check_bidi: bool,
    check_hyphens: bool,
    check_joiners: bool,
    ignore_invalid_punycode: bool,
    std3: bool,
}

const WHATWG_STRICT: ToAsciiConfig = ToAsciiConfig {
    check_bidi: true,
    check_hyphens: true,
    check_joiners: true,
    ignore_invalid_punycode: false,
    std3: true,
};

const WHATWG_LAX: ToAsciiConfig = ToAsciiConfig {
    check_bidi: true,
    check_hyphens: false,
    check_joiners: true,
    ignore_invalid_punycode: false,
    std3: false,
};

/*
#[inline]
fn map_internal(mut new: String, old: &str) -> String {
    for c in old.chars() {
        match idna_map(c) {
            Status::Ignored => continue,
            Status::Mapped(sl) => new.extend(sl),
            _ => new.push(c),
        }
    }
    new
}
*/

#[inline]
fn map_internal(mut new: String, old: &str) -> String {
    for c in old.chars() {
        match idna_map(c) {
            Status::Ignored => continue,
            Status::Mapped(sl) => new.extend(sl),
            _ => new.push(c),
        }
    }
    new
}

/*
#[must_use]
pub fn map(s: &str) -> Cow<str> {
    for (i, c) in s.char_indices() {
        match idna_map(c) {
            Status::Ignored => {
                let mut new = String::new();
                new.push_str(&s[..i]);
                return Cow::Owned(map_internal(new, &s[i + c.len_utf8()..]));
            }

            Status::Mapped(sl) => {
                let mut new = String::new();
                new.push_str(&s[..i]);
                new.extend(sl);
                return Cow::Owned(map_internal(new, &s[i + c.len_utf8()..]));
            }

            _ => continue,
        }
    }

    Cow::Borrowed(s)
}
*/

#[must_use]
pub fn map(s: &str) -> Cow<str> {
    for (i, c) in s.char_indices() {
        match idna_map(c) {
            Status::Ignored => {
                let mut new = String::new();
                new.push_str(&s[..i]);
                return Cow::Owned(map_internal(new, &s[i + c.len_utf8()..]));
            }

            Status::Mapped(sl) => {
                let mut new = String::new();
                new.push_str(&s[..i]);
                new.extend(sl);
                return Cow::Owned(map_internal(new, &s[i + c.len_utf8()..]));
            }

            _ => continue,
        }
    }

    Cow::Borrowed(s)
}

#[must_use]
pub fn normalize(s: &str) -> Cow<str> {
    if is_nfc(s) {
        return Cow::Borrowed(s);
    }

    Cow::Owned(s.nfc().collect::<String>())
}

#[must_use]
fn normalize_always(s: &str) -> String {
    s.nfc().collect::<String>()
}

/*
pub fn convert_validate(s: &str) -> Cow<str> {
    let i = s.split('.');

    for label in i {
        if label.starts_with("xn--") {
            if !label.is_ascii() {
                todo!("error");
            }


        }
    }
}
*/
